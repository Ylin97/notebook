# 共享全局变量知识总结

### 一、共享全局变量正确写法

首先需要在一个`.cpp`文件中定义全局变量，然后在它对应的头文件中用`extern`关键字声明（在头文件里声明主要是为了防止自己用这个全局变量的时候忘记写`extern`，如果漏写`extern`那就不是这个全局变量而是重新分配的新变量了）。例如，

```cpp
// def.h
extern int kTotal;   // 这里只是声明了变量，并没有定义它（即没有在内存中为之分配空间）
```

```cpp
// def.cpp
int kTotal = 0;      // 这里才是定义 kTotal 变量，它实实在在分配了内存
```

如果我们要在其他文件中使用它，就可以包含`def.h`头文件，或者自己手动写`extern int kTotal;`告诉编译器这个变量来自其他翻译单元（通常一个翻译单元就是一个 cpp 文件）。

```cpp
// test1.cpp

#include "def.h"  // 包含头文件

// extern int kTotal;  /* 手动声明外部变量, 因为头文件里面已经写了，所以这里可以不写，
                       /* 但是写上也没关系，因为声明可以多次进行，extern 语句写多少次都行 */
void f1() {
    kTotal = 3;
    std::cout << "kTotal = "<< kTotal << std::endl;  
    kTotal = 5;
}

void f2() {
    std::cout << "kTotal = " << kTotal << std::endl; 
}

int main() {
    f1();    // 输出 kTotal = 3
    f2();    // 输出 kTotal = 5;
    return 0;
}
```

再测试另一个 cpp 文件：

```cpp
// test2.cpp

#include "def.h"

void f3() {
    // 这里通过头文件声明了外部变量 kTotal
    std::cout << "kTotal = " << kTotal << std::endl; // 输出 kTotal = 5;
    
    int kTotal = 66;  // 局部变量优先级高于全局变量，所以全局的 kTotal 会被隐藏
    std::cout << "kTotal = " << kTotal << std::endl; // 输出 kTotal = 66;
}

int main() {
    f3();     // 输出：kTotal = 5;
              //      kTotal = 66
    
    cout << "kTotal = " << kTotal << endl;  // 因为这里是全局的 kTotal ，所以输出 kTotal = 5
    return 0;
}
```

#### 总结：

- 在头文件里面只写全局变量的`extern`声明，不能写变量定义，否则多次包含该头文件时会报错。
- 全局变量的定义应该写到头文件对应的`.cpp`文件中，且只准许定义一次。
- 其他文件中引用这个全局变量时，应该包含头文件或者手动用`extern`进行声明。

### 二、static 变量

`static`关键字主要有三个作用：

- 顶层的`static`用来限制函数或变量为**仅本文件可见**（函数和全局变量默认是是外部可见的，即所谓的“外部链接”）
- 函数内部的`static`用来定义局部静态变量
- 类里面的`static`用来定义类属性和类方法（即不属于对象而属于类的变量和函数，这些变量和函数每个类只有一份，可以给所有对象共享，或者直接通过类名访问）

从上面第一条可知，对于顶层的变量（全局变量），`static`关键字和`extern`关键字是不能同时使用的，因为前者是限制变量为仅本文件可见，而后者确声明变量来自外部，所以两者是矛盾的。

C++中还可以使用单例模式（Singleton）来代替全局变量：

```cpp
// myclass.h

class MyClass {
public:
    /**
     * 局部静态特性的方式实现单实例。
     * 静态局部变量只在当前函数内有效，其他函数无法访问。
     * 静态局部变量只在第一次被调用的时候初始化，也存储在静态存储区，生命周期从第一次被初始化起至程序结束止。
     */
    static MyClass& GetInstance() {
        static MyClass instance;
        return instance;
    }
    
    void SetValue(int val) {
        data = val;
    }
    
    int GetValue() {
        return data;
    }
    
private:
    int data = 0;
};
```

```cpp
// test.cpp
#include "myclass.h"

int main() {
    MyClass& instance = MyClass::GetInstance();  // 获取单例对象
    instance.SetValue(5);
    std::cout << "value = " << instance.GetValue() << std::endl; // 输出 value = 5
    
    return 0;
}
```





