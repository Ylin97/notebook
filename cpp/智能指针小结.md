# 智能指针

## weak_ptr

`std::weak_ptr` 是 C++ 智能指针家族中的“观察者”，它**不增加引用计数，也不拥有对象的所有权**，而是**弱引用（weak reference）一个由 `shared_ptr` 管理的对象**。

它的主要用途是：

---

### ✅ 1. **打破 `shared_ptr` 的循环引用（Circular Reference）**
这是 `weak_ptr` 最重要、最经典的使用场景。

#### ❌ 问题：循环引用导致内存泄漏
```cpp
struct Node {
    shared_ptr<Node> parent;
    shared_ptr<Node> child;
};

int main() {
    auto node1 = make_shared<Node>();
    auto node2 = make_shared<Node>();
    node1->child = node2;
    node2->parent = node1; // 循环引用！
}
```
- `node1` 引用 `node2`（引用计数=1）
- `node2` 引用 `node1`（引用计数=1）
- 即使 `node1` 和 `node2` 超出作用域，引用计数也不会归零，内存无法释放！

#### ✅ 解决方案：用 `weak_ptr` 打破循环
```cpp
struct Node {
    shared_ptr<Node> child;
    weak_ptr<Node> parent; // 改为 weak_ptr
};
```
现在 `parent` 不增加引用计数，循环被打破，对象可以正确析构。

> 📌 **典型场景**：树结构中的父子关系、双向链表、观察者模式（如你之前的例子）。

---

### ✅ 2. **缓存（Cache）或资源池**
当你想缓存一些对象，但又不希望缓存本身阻止对象被销毁。

```cpp
class ObjectCache {
    unordered_map<string, weak_ptr<MyObject>> cache;
public:
    shared_ptr<MyObject> get(const string& key) {
        auto it = cache.find(key);
        if (it != cache.end()) {
            if (auto obj = it->second.lock()) { // 尝试提升为 shared_ptr
                return obj; // 对象还活着，返回共享引用
            }
        }
        // 对象已销毁，重新创建
        auto newObj = make_shared<MyObject>(key);
        cache[key] = newObj;
        return newObj;
    }
};
```
- `weak_ptr` 允许对象在无人使用时自动销毁。
- 下次访问时如果对象还在，就复用；否则重建。

> 📌 **典型场景**：数据库连接池、图像缓存、字符串驻留等。

---

### ✅ 3. **观察者模式中的“观察者”对“被观察者”的引用**
正如你之前的例子：

```cpp
class Observer {
    weak_ptr<Subject> subject; // 观察者不应延长被观察者的生命周期
public:
    void update() {
        if (auto s = subject.lock()) {
            cout << "Subject action: " << s->action << endl;
        }
    }
};
```
- 被观察者（Subject）管理自己的生命周期。
- 观察者只是“监听”，不应阻止 Subject 被销毁。

---

### ✅ 4. **避免悬空指针的“安全裸指针”替代**
`weak_ptr` 可以看作是比裸指针更安全的“临时引用”。

```cpp
weak_ptr<Data> globalRef;

void setRef(shared_ptr<Data> data) {
    globalRef = data;
}

void useRef() {
    if (auto p = globalRef.lock()) { // 安全检查
        p->process();
    } else {
        cout << "Data has been destroyed." << endl;
    }
}
```
相比裸指针，`weak_ptr` 可以检测对象是否还存在。

---

### ✅ 5. **延迟初始化（Lazy Initialization）或单例的线程安全实现**
结合 `shared_ptr` 和 `weak_ptr` 实现线程安全的单例缓存：

```cpp
static weak_ptr<MySingleton> cache;

shared_ptr<MySingleton> getInstance() {
    if (auto ptr = cache.lock()) {
        return ptr;
    }
    auto newPtr = make_shared<MySingleton>();
    cache = newPtr;
    return newPtr;
}
```

---

### ⚠️ 使用 `weak_ptr` 的注意事项

1. **不能直接使用**：必须通过 `.lock()` 提升为 `shared_ptr`。
2. **`.lock()` 返回 `shared_ptr<T>`**：如果原对象已销毁，返回空 `shared_ptr`。
3. **性能开销**：`.lock()` 需要线程安全地检查控制块，有一定开销。
4. **不要长期持有 `lock()` 的结果**：避免不必要的引用计数增加。

---

### 总结：建议使用 `weak_ptr` 的场景

| 场景                        | 说明                           |
| --------------------------- | ------------------------------ |
| 🔁 **打破循环引用**          | 树形结构、双向关联、观察者模式 |
| 🧠 **缓存 / 资源池**         | 希望对象在无人使用时自动销毁   |
| 👀 **观察者引用被观察者**    | 不应延长被观察者生命周期       |
| 🛡️ **安全的临时引用**        | 替代裸指针，避免悬空           |
| 🧩 **延迟初始化 / 单例缓存** | 线程安全地复用对象             |

> 💡 **口诀**：**当你需要“知道一个对象是否存在”，但又不想“决定它是否存活”时，就用 `weak_ptr`。**

它是 `shared_ptr` 的完美搭档，帮助你在共享所有权的同时，避免内存泄漏和逻辑错误。