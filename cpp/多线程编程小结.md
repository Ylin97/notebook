# 多线程编程小结

## 基础知识

- **C++11** 开始引入标准线程库 `<thread>`，统一封装了底层的操作系统线程（如 POSIX pthread、Windows thread），让多线程编程更简洁。

- 线程通过 `std::thread` 创建，使用时需关注数据竞争和同步，可使用 `std::mutex`、`std::lock_guard`、`std::unique_lock`、`std::condition_variable` 等工具。

  ```cpp
  void Work() { /* ... */ }
  std::thread t(Work);  // 启动线程
  t.join();             // 等待线程结束
  ```

- **线程生命周期**
   线程启动后必须通过 `join()` 等待结束，或通过 `detach()` 让其独立运行。否则在对象析构时会导致程序终止。`join()` 的语义和作用见【[此处](#`join` 的语义、作用与历史)】。

------

## 传递引用问题

- 多线程函数传参时，如果要 **按引用传递**，必须使用 `std::ref` 包装，否则会进行按值复制甚至无法编译：

  ```cpp
  void Worker(int &var) { /* ... */ }
  
  int main() {
      int var = 0;
      std::thread t(Worker, std::ref(var)); // ✅ 按引用传递
      t.join();
  }
  ```

------

## joinable() 检查与 join

- 调用 `join()` 或 `detach()` 之前务必检查：

  ```cpp
  if (t.joinable()) t.join();
  ```

- `joinable()` 为 `false` 的几种情况：

  1. 线程对象默认构造；
  2. 已经调用过 `join()`；
  3. 已经调用过 `detach()`；
  4. 已经被移动赋值。

------

## 同步与互斥

### 互斥量（mutex）

- 使用 `std::mutex` 和 `std::lock_guard`/`std::unique_lock` 保护共享数据：

  ```cpp
  std::mutex m;
  int shared = 0;
  
  void Increment() {
      std::lock_guard<std::mutex> lk(m);
      ++shared;
  }
  ```

- `std::lock_guard` 提供 RAII 自动解锁，避免忘记释放锁。

### 条件变量（condition_variable）

- 用于线程间等待/通知：

  ```cpp
  std::condition_variable cv;
  std::mutex m;
  bool ready = false;
  
  void Producer() {
      {
          std::lock_guard<std::mutex> lk(m);
          ready = true;
      }
      cv.notify_one();
  }
  
  void Consumer() {
      std::unique_lock<std::mutex> lk(m);
      cv.wait(lk, []{ return ready; });
      // 消费
  }
  ```

------

## detach() 与资源管理

- `detach()` 会让线程在后台独立运行，但此时无法再 `join()`，也无法确定其何时结束：

  ```cpp
  std::thread t(Work);
  t.detach();  // 主线程不再管理此线程
  ```

- 适用于短生命周期任务，但要避免访问已经销毁的资源。

------

## 原子操作

- `std::atomic<T>` 提供无锁的线程安全操作：

  ```cpp
  std::atomic<int> counter{0};
  void Increment() { counter.fetch_add(1); }
  ```

- 适用于简单计数或标志位，而不必使用互斥量。

------

## 线程局部存储

- 使用 `thread_local` 为每个线程维护独立副本：

  ```cpp
  thread_local int localVar = 0;
  ```

------

## 线程池与任务调度

- 为了避免频繁创建/销毁线程，常用**线程池**。线程池会维护一组工作线程，从任务队列中取出任务执行。
- 改进点：
  - 动态伸缩：根据任务负载增减线程数量；
  - 任务优先级：使用 `std::priority_queue`；
  - 异常处理：在工作线程内捕获异常，避免线程崩溃；
  - 监控：周期性输出线程池状态。

------

## 常见陷阱与最佳实践

- ❗ **忘记 join/detach**：导致程序异常终止。
- ❗ **数据竞争**：多个线程未同步访问共享数据。
- ❗ **死锁**：锁获取顺序不当或重复加锁。
- ✅ 使用 RAII（如 `lock_guard`）管理锁。
- ✅ 避免长时间持有锁，缩小临界区范围。
- ✅ 使用 `std::async`、`std::future` 简化异步任务。
- ✅ 对复杂场景使用现成库（如 TBB、Boost.Thread、Folly）。

------

### 🌟 **总结**

C++11 及之后的标准库提供了跨平台的线程与同步机制，使多线程编程更安全、更易用。掌握基本 API（`thread`、`mutex`、`condition_variable`、`atomic`）后，再结合线程池、任务优先级和动态伸缩等高级技术，就能构建高性能、可扩展的多线程程序。

------

## 附录

> ### `join` 的语义、作用与历史
>
> #### ✨ **语义和作用**
> 
> - `join()` 的意思是：**让当前线程等待（“加入”）另一个线程，直到那个线程运行结束**。
> - 调用 `t.join()` 的线程会 **阻塞**，直到线程 `t` 完成。此时两个线程的执行流在这一点 **汇合（join）**，形成同步点。
> - 调用后，`t` 与底层线程解绑，`t.joinable() == false`。
> - **用途**：
>   - 确保后台任务完成并释放资源。
>   - 在程序退出或继续依赖线程结果时，确保线程安全结束。
> 
> #### 🕰 **历史与比喻**
> 
> - **历史背景**：
>   - “join” 一词源自早期 Unix 和 POSIX 线程库（`pthread_join`），语义是“在这里汇合”。
> - **形象比喻**：
>   - 启动线程就像走出一条分叉的小路。
>   - 主线程执行到 `join()` 时，会在此等待那条分叉小路回到主路，类似**道路汇合（join paths）**。
> 
> #### 🧩惯用写法
> 
> ```
> for (auto &worker : workers) {
>     if (worker.joinable()) {  // ✅ 检查是否可 join
>         worker.join();        // ✅ 等待线程完成并回收资源
>     }
> }
> ```
