# å¤šçº¿ç¨‹ç¼–ç¨‹å°ç»“

## åŸºç¡€çŸ¥è¯†

- **C++11** å¼€å§‹å¼•å…¥æ ‡å‡†çº¿ç¨‹åº“ `<thread>`ï¼Œç»Ÿä¸€å°è£…äº†åº•å±‚çš„æ“ä½œç³»ç»Ÿçº¿ç¨‹ï¼ˆå¦‚ POSIX pthreadã€Windows threadï¼‰ï¼Œè®©å¤šçº¿ç¨‹ç¼–ç¨‹æ›´ç®€æ´ã€‚

- çº¿ç¨‹é€šè¿‡ `std::thread` åˆ›å»ºï¼Œä½¿ç”¨æ—¶éœ€å…³æ³¨æ•°æ®ç«äº‰å’ŒåŒæ­¥ï¼Œå¯ä½¿ç”¨ `std::mutex`ã€`std::lock_guard`ã€`std::unique_lock`ã€`std::condition_variable` ç­‰å·¥å…·ã€‚

  ```cpp
  void Work() { /* ... */ }
  std::thread t(Work);  // å¯åŠ¨çº¿ç¨‹
  t.join();             // ç­‰å¾…çº¿ç¨‹ç»“æŸ
  ```

- **çº¿ç¨‹ç”Ÿå‘½å‘¨æœŸ**
   çº¿ç¨‹å¯åŠ¨åå¿…é¡»é€šè¿‡ `join()` ç­‰å¾…ç»“æŸï¼Œæˆ–é€šè¿‡ `detach()` è®©å…¶ç‹¬ç«‹è¿è¡Œã€‚å¦åˆ™åœ¨å¯¹è±¡ææ„æ—¶ä¼šå¯¼è‡´ç¨‹åºç»ˆæ­¢ã€‚`join()` çš„è¯­ä¹‰å’Œä½œç”¨è§ã€[æ­¤å¤„](#1. join çš„è¯­ä¹‰ã€ä½œç”¨ä¸å†å²)ã€‘ã€‚

------

## ä¼ é€’å¼•ç”¨é—®é¢˜

- å¤šçº¿ç¨‹å‡½æ•°ä¼ å‚æ—¶ï¼Œå¦‚æœè¦ **æŒ‰å¼•ç”¨ä¼ é€’**ï¼Œå¿…é¡»ä½¿ç”¨ `std::ref` åŒ…è£…ï¼Œå¦åˆ™ä¼šè¿›è¡ŒæŒ‰å€¼å¤åˆ¶ç”šè‡³æ— æ³•ç¼–è¯‘ï¼š

  ```cpp
  void Worker(int &var) { /* ... */ }
  
  int main() {
      int var = 0;
      std::thread t(Worker, std::ref(var)); // âœ… æŒ‰å¼•ç”¨ä¼ é€’
      t.join();
  }
  ```

------

## joinable() æ£€æŸ¥ä¸ join

- è°ƒç”¨ `join()` æˆ– `detach()` ä¹‹å‰åŠ¡å¿…æ£€æŸ¥ï¼š

  ```cpp
  if (t.joinable()) t.join();
  ```

- `joinable()` ä¸º `false` çš„å‡ ç§æƒ…å†µï¼š

  1. çº¿ç¨‹å¯¹è±¡é»˜è®¤æ„é€ ï¼›
  2. å·²ç»è°ƒç”¨è¿‡ `join()`ï¼›
  3. å·²ç»è°ƒç”¨è¿‡ `detach()`ï¼›
  4. å·²ç»è¢«ç§»åŠ¨èµ‹å€¼ã€‚

------

## åŒæ­¥ä¸äº’æ–¥

### äº’æ–¥é‡ï¼ˆmutexï¼‰

- ä½¿ç”¨ `std::mutex` å’Œ `std::lock_guard`/`std::unique_lock` ä¿æŠ¤å…±äº«æ•°æ®ï¼š

  ```cpp
  std::mutex m;
  int shared = 0;
  
  void Increment() {
      std::lock_guard<std::mutex> lk(m);
      ++shared;
  }
  ```

- `std::lock_guard` å’Œ `std::unique_lock` éƒ½æä¾› RAII è‡ªåŠ¨è§£é”ï¼Œé¿å…å¿˜è®°é‡Šæ”¾é”ã€‚ä¸¤è€…çš„ä¸»è¦åŒºåˆ«æ˜¯ `std::unique_lock` æ”¯æŒæ‰‹åŠ¨åŠ è§£é”ï¼Œè€Œ `std::lock_guard` ä¸æ”¯æŒã€‚å…·ä½“å¯¹æ¯”è§ã€[æ­¤å¤„](#2. lock_guard å’Œ unique_lock çš„åŒºåˆ«)ã€‘

### æ¡ä»¶å˜é‡ï¼ˆcondition_variableï¼‰

- ç”¨äºçº¿ç¨‹é—´ç­‰å¾…/é€šçŸ¥ï¼š

  ```cpp
  std::condition_variable cv;
  std::mutex m;
  bool ready = false;
  
  void Producer() {
      {
          std::lock_guard<std::mutex> lk(m);
          ready = true;
      }
      cv.notify_one();
  }
  
  void Consumer() {
      std::unique_lock<std::mutex> lk(m);
      cv.wait(lk, []{ return ready; });
      // æ¶ˆè´¹
  }
  ```

------

## detach() ä¸èµ„æºç®¡ç†

- `detach()` ä¼šè®©çº¿ç¨‹åœ¨åå°ç‹¬ç«‹è¿è¡Œï¼Œä½†æ­¤æ—¶æ— æ³•å† `join()`ï¼Œä¹Ÿæ— æ³•ç¡®å®šå…¶ä½•æ—¶ç»“æŸï¼š

  ```cpp
  std::thread t(Work);
  t.detach();  // ä¸»çº¿ç¨‹ä¸å†ç®¡ç†æ­¤çº¿ç¨‹
  ```

- é€‚ç”¨äºçŸ­ç”Ÿå‘½å‘¨æœŸä»»åŠ¡ï¼Œä½†è¦é¿å…è®¿é—®å·²ç»é”€æ¯çš„èµ„æºã€‚

------

## åŸå­æ“ä½œ

- `std::atomic<T>` æä¾›æ— é”çš„çº¿ç¨‹å®‰å…¨æ“ä½œï¼š

  ```cpp
  std::atomic<int> counter{0};
  void Increment() { counter.fetch_add(1); }
  ```

- é€‚ç”¨äºç®€å•è®¡æ•°æˆ–æ ‡å¿—ä½ï¼Œè€Œä¸å¿…ä½¿ç”¨äº’æ–¥é‡ã€‚

------

## çº¿ç¨‹å±€éƒ¨å­˜å‚¨

- ä½¿ç”¨ `thread_local` ä¸ºæ¯ä¸ªçº¿ç¨‹ç»´æŠ¤ç‹¬ç«‹å‰¯æœ¬ï¼š

  ```cpp
  thread_local int localVar = 0;
  ```

------

## çº¿ç¨‹æ± ä¸ä»»åŠ¡è°ƒåº¦

- ä¸ºäº†é¿å…é¢‘ç¹åˆ›å»º/é”€æ¯çº¿ç¨‹ï¼Œå¸¸ç”¨**çº¿ç¨‹æ± **ã€‚çº¿ç¨‹æ± ä¼šç»´æŠ¤ä¸€ç»„å·¥ä½œçº¿ç¨‹ï¼Œä»ä»»åŠ¡é˜Ÿåˆ—ä¸­å–å‡ºä»»åŠ¡æ‰§è¡Œã€‚
- æ”¹è¿›ç‚¹ï¼š
  - åŠ¨æ€ä¼¸ç¼©ï¼šæ ¹æ®ä»»åŠ¡è´Ÿè½½å¢å‡çº¿ç¨‹æ•°é‡ï¼›
  - ä»»åŠ¡ä¼˜å…ˆçº§ï¼šä½¿ç”¨ `std::priority_queue`ï¼›
  - å¼‚å¸¸å¤„ç†ï¼šåœ¨å·¥ä½œçº¿ç¨‹å†…æ•è·å¼‚å¸¸ï¼Œé¿å…çº¿ç¨‹å´©æºƒï¼›
  - ç›‘æ§ï¼šå‘¨æœŸæ€§è¾“å‡ºçº¿ç¨‹æ± çŠ¶æ€ã€‚

------

## å¸¸è§é™·é˜±ä¸æœ€ä½³å®è·µ

- â— **å¿˜è®° join/detach**ï¼šå¯¼è‡´ç¨‹åºå¼‚å¸¸ç»ˆæ­¢ã€‚
- â— **æ•°æ®ç«äº‰**ï¼šå¤šä¸ªçº¿ç¨‹æœªåŒæ­¥è®¿é—®å…±äº«æ•°æ®ã€‚
- â— **æ­»é”**ï¼šé”è·å–é¡ºåºä¸å½“æˆ–é‡å¤åŠ é”ã€‚
- âœ… ä½¿ç”¨ RAIIï¼ˆå¦‚ `lock_guard`ï¼‰ç®¡ç†é”ã€‚
- âœ… é¿å…é•¿æ—¶é—´æŒæœ‰é”ï¼Œç¼©å°ä¸´ç•ŒåŒºèŒƒå›´ã€‚
- âœ… ä½¿ç”¨ `std::async`ã€`std::future` ç®€åŒ–å¼‚æ­¥ä»»åŠ¡ã€‚
- âœ… å¯¹å¤æ‚åœºæ™¯ä½¿ç”¨ç°æˆåº“ï¼ˆå¦‚ TBBã€Boost.Threadã€Follyï¼‰ã€‚

------

### ğŸŒŸ **æ€»ç»“**

C++11 åŠä¹‹åçš„æ ‡å‡†åº“æä¾›äº†è·¨å¹³å°çš„çº¿ç¨‹ä¸åŒæ­¥æœºåˆ¶ï¼Œä½¿å¤šçº¿ç¨‹ç¼–ç¨‹æ›´å®‰å…¨ã€æ›´æ˜“ç”¨ã€‚æŒæ¡åŸºæœ¬ APIï¼ˆ`thread`ã€`mutex`ã€`condition_variable`ã€`atomic`ï¼‰åï¼Œå†ç»“åˆçº¿ç¨‹æ± ã€ä»»åŠ¡ä¼˜å…ˆçº§å’ŒåŠ¨æ€ä¼¸ç¼©ç­‰é«˜çº§æŠ€æœ¯ï¼Œå°±èƒ½æ„å»ºé«˜æ€§èƒ½ã€å¯æ‰©å±•çš„å¤šçº¿ç¨‹ç¨‹åºã€‚

------

## é™„å½•

> ### 1. join çš„è¯­ä¹‰ã€ä½œç”¨ä¸å†å²
>
> #### âœ¨ **è¯­ä¹‰å’Œä½œç”¨**
>
> - `join()` çš„æ„æ€æ˜¯ï¼š**è®©å½“å‰çº¿ç¨‹ç­‰å¾…ï¼ˆâ€œåŠ å…¥â€ï¼‰å¦ä¸€ä¸ªçº¿ç¨‹ï¼Œç›´åˆ°é‚£ä¸ªçº¿ç¨‹è¿è¡Œç»“æŸ**ã€‚
> - è°ƒç”¨ `t.join()` çš„çº¿ç¨‹ä¼š **é˜»å¡**ï¼Œç›´åˆ°çº¿ç¨‹ `t` å®Œæˆã€‚æ­¤æ—¶ä¸¤ä¸ªçº¿ç¨‹çš„æ‰§è¡Œæµåœ¨è¿™ä¸€ç‚¹ **æ±‡åˆï¼ˆjoinï¼‰**ï¼Œå½¢æˆåŒæ­¥ç‚¹ã€‚
> - è°ƒç”¨åï¼Œ`t` ä¸åº•å±‚çº¿ç¨‹è§£ç»‘ï¼Œ`t.joinable() == false`ã€‚
> - **ç”¨é€”**ï¼š
>   - ç¡®ä¿åå°ä»»åŠ¡å®Œæˆå¹¶é‡Šæ”¾èµ„æºã€‚
>   - åœ¨ç¨‹åºé€€å‡ºæˆ–ç»§ç»­ä¾èµ–çº¿ç¨‹ç»“æœæ—¶ï¼Œç¡®ä¿çº¿ç¨‹å®‰å…¨ç»“æŸã€‚
>
> #### ğŸ•° **å†å²ä¸æ¯”å–»**
>
> - **å†å²èƒŒæ™¯**ï¼š
>   - â€œjoinâ€ ä¸€è¯æºè‡ªæ—©æœŸ Unix å’Œ POSIX çº¿ç¨‹åº“ï¼ˆ`pthread_join`ï¼‰ï¼Œè¯­ä¹‰æ˜¯â€œåœ¨è¿™é‡Œæ±‡åˆâ€ã€‚
> - **å½¢è±¡æ¯”å–»**ï¼š
>   - å¯åŠ¨çº¿ç¨‹å°±åƒèµ°å‡ºä¸€æ¡åˆ†å‰çš„å°è·¯ã€‚
>   - ä¸»çº¿ç¨‹æ‰§è¡Œåˆ° `join()` æ—¶ï¼Œä¼šåœ¨æ­¤ç­‰å¾…é‚£æ¡åˆ†å‰å°è·¯å›åˆ°ä¸»è·¯ï¼Œç±»ä¼¼**é“è·¯æ±‡åˆï¼ˆjoin pathsï¼‰**ã€‚
>
> #### ğŸ§©æƒ¯ç”¨å†™æ³•
>
> ```cpp
> for (auto &worker : workers) {
>     if (worker.joinable()) {  // âœ… æ£€æŸ¥æ˜¯å¦å¯ join
>         worker.join();        // âœ… ç­‰å¾…çº¿ç¨‹å®Œæˆå¹¶å›æ”¶èµ„æº
>     }
> }
> ```
>
> ### 2. lock_guard å’Œ unique_lock çš„åŒºåˆ«
>
> #### ğŸ”’ ä¸¤è€…çš„å…±åŒç‚¹
>
> | ç‰¹æ€§           | è¯´æ˜                                                       |
> | -------------- | ---------------------------------------------------------- |
> | **RAII**       | æ„é€ å‡½æ•°æ—¶åŠ é”ï¼Œææ„å‡½æ•°æ—¶è‡ªåŠ¨è§£é”ã€‚                       |
> | **ä½œç”¨åŸŸç®¡ç†** | å½“å¯¹è±¡ç¦»å¼€ä½œç”¨åŸŸï¼ˆæ­£å¸¸è¿”å›æˆ–å¼‚å¸¸æŠ›å‡ºï¼‰æ—¶ï¼Œé”ä¼šè¢«è‡ªåŠ¨é‡Šæ”¾ã€‚ |
> | **å¼‚å¸¸å®‰å…¨**   | å³ä½¿å‘ç”Ÿå¼‚å¸¸ï¼Œææ„å‡½æ•°ä»ä¼šæ‰§è¡Œï¼Œé˜²æ­¢æ­»é”ã€‚                 |
>
> ------
>
> #### ğŸ”§ ä¸¤è€…çš„ä¸»è¦åŒºåˆ«
>
> | æ¯”è¾ƒé¡¹               | `std::lock_guard`                      | `std::unique_lock`                                           |
> | -------------------- | -------------------------------------- | ------------------------------------------------------------ |
> | **æ˜¯å¦æ”¯æŒæ‰‹åŠ¨è§£é”** | âŒ ä¸æ”¯æŒï¼Œé”å®šåå¿…é¡»ç­‰ä½œç”¨åŸŸç»“æŸæ‰è§£é” | âœ… æ”¯æŒ `unlock()` å’Œ `lock()` é‡æ–°åŠ é”                       |
> | **å»¶è¿ŸåŠ é”**         | âŒ ä¸æ”¯æŒï¼Œæ„é€ æ—¶å°±å¿…é¡»ç«‹å³åŠ é”         | âœ… å¯ä»¥ç”¨ `std::defer_lock` å»¶è¿ŸåŠ é”ï¼Œæˆ–ç”¨ `try_to_lock` å°è¯• |
> | **å’Œæ¡ä»¶å˜é‡é…åˆ**   | âŒ ä¸é€‚åˆï¼ˆæ— æ³•åœ¨ç­‰å¾…æœŸé—´é‡Šæ”¾é”ï¼‰       | âœ… ä¸ `std::condition_variable::wait` ç­‰é…åˆä½¿ç”¨              |
> | **å¼€é”€**             | è¾ƒå°ï¼Œæ¥å£ç®€å•                         | ç•¥å¤§ä¸€äº›ï¼ˆå› ä¸ºæä¾›æ›´å¤šçµæ´»æ€§ï¼‰                               |
>
> ------
>
> #### âœ… **ç¤ºä¾‹ï¼š`lock_guard`ï¼ˆç®€å•é”ï¼‰**
>
> ```cpp
> std::mutex mtx;
> 
> void foo() {
>     std::lock_guard<std::mutex> lock(mtx); // æ„é€ æ—¶åŠ é”
>     // ä¸´ç•ŒåŒº
> } // ä½œç”¨åŸŸç»“æŸï¼Œè‡ªåŠ¨è§£é”
> ```
>
> ------
>
> #### âœ… **ç¤ºä¾‹ï¼š`unique_lock`ï¼ˆçµæ´»é”ï¼‰**
>
> ```cpp
> std::mutex mtx;
> 
> void bar() {
>     std::unique_lock<std::mutex> lock(mtx); // æ„é€ æ—¶åŠ é”
>     // å¯ä»¥åœ¨è¿™é‡Œæå‰è§£é”
>     lock.unlock();
> 
>     // éœ€è¦æ—¶é‡æ–°åŠ é”
>     lock.lock();
> } // ææ„æ—¶å¦‚æœè¿˜æŒæœ‰é”ï¼Œä¼šè‡ªåŠ¨è§£é”
> ```
>
> ### 3. æ”¯æŒåŠ¨æ€ä¼¸ç¼©çš„ç®€æ˜“ç‰ˆçº¿ç¨‹æ± å®ç°
>
> ```cpp
> #include <iostream>
> #include <thread>
> #include <mutex>
> #include <condition_variable>
> #include <queue>
> #include <vector>
> #include <functional>
> #include <chrono>
> #include <atomic>
> #include <algorithm>
> 
> struct Task {
>     int priority; // ä¼˜å…ˆçº§ï¼Œæ•°å€¼è¶Šå¤§ä¼˜å…ˆçº§è¶Šé«˜
>     std::function<void()> func;
> 
>     bool operator<(const Task &rhs) const {
>         return priority < rhs.priority; // å¤§é¡¶å †
>     }
> };
> 
> class SmartThreadPool {
> public:
>     explicit SmartThreadPool(size_t min_threads = 2, size_t max_threads = 8,
>                              std::chrono::milliseconds idle_timeout = std::chrono::milliseconds(2000))
>         : min_threads_(min_threads), max_threads_(max_threads), idle_timeout_(idle_timeout),
>           active_threads_(0), completed_tasks_(0), alive_threads_(0), stop_(false) {
>         for (size_t i = 0; i < min_threads_; ++i) {
>             AddWorker();
>         }
>         monitor_ = std::thread([this] { MonitorLoop(); });
>     }
> 
>     ~SmartThreadPool() {
>         {
>             std::lock_guard<std::mutex> lock(mtx_);
>             stop_ = true;
>         }
>         cv_.notify_all();
> 
>         for (auto &worker : workers_) {
>             if (worker.joinable()) worker.join();
>         }
>         if (monitor_.joinable()) monitor_.join();
>     }
> 
>     void Enqueue(std::function<void()> task, int priority = 0) {
>         {
>             std::lock_guard<std::mutex> lock(mtx_);
>             tasks_.push(Task{priority, std::move(task)});
> 
>             if (active_threads_ >= alive_threads_ && workers_.size() < max_threads_) {
>                 AddWorker();
>             }
>         }
>         cv_.notify_one();
>     }
> 
> private:
>     std::vector<std::thread> workers_;
>     std::priority_queue<Task> tasks_;
>     std::mutex mtx_;
>     std::condition_variable cv_;
>     std::atomic<bool> stop_;
> 
>     size_t min_threads_;
>     size_t max_threads_;
>     std::chrono::milliseconds idle_timeout_;
> 
>     std::atomic<size_t> active_threads_;
>     std::atomic<size_t> completed_tasks_;
>     std::atomic<size_t> alive_threads_;
> 
>     std::thread monitor_;
> 
> private:
>     void AddWorker() {
>         // æˆ–ç”¨ä¼ ç»Ÿæ–¹å¼
>         // workers_.emplace_back(&SmartThreadPool::WorkerLoop, this));
>         workers_.emplace_back([this] { WorkerLoop(); });
>     }
> 
>     void WorkerLoop() {
>         ++alive_threads_;
>         while (true) {
>             Task task;
>             { // å–ä»»åŠ¡
>                 std::unique_lock<std::mutex> lock(mtx_);
>                 if (!cv_.wait_for(lock, idle_timeout_, [this] { return stop_ || !tasks_.empty(); })) { // çº¿ç¨‹ç©ºé—²è¶…æ—¶
>                     if (workers_.size() > min_threads_) {
>                         --alive_threads_;
>                         return;
>                     }
>                     continue;
>                 }
>                 if (stop_ && tasks_.empty()) {
>                     --alive_threads_;
>                     return;
>                 }
> 
>                 task = std::move(tasks_.top());
>                 tasks_.pop();
>             }
> 
>             ++active_threads_;
>             try {
>                 task.func();
>             } catch (const std::exception &e) {
>                 std::cerr << "[å¼‚å¸¸æ•è·] " << e.what() << '\n';
>             } catch (...) {
>                 std::cerr << "[å¼‚å¸¸æ•è·] " << "æœªçŸ¥å¼‚å¸¸" << '\n';
>             }
>             --active_threads_;
>             ++completed_tasks_;
>         }
>     }
> 
>     void MonitorLoop() {
>         while (!stop_) {
>             std::this_thread::sleep_for(std::chrono::seconds(1)); // æš‚åœ1ç§’ï¼Œé¿å…é¢‘ç¹é”
>             {
>                 std::lock_guard<std::mutex> lock(mtx_);
>                 CleanUpDeadThreads();
>                 std::cout << "[ç›‘æ§] æ´»åŠ¨çº¿ç¨‹: " << active_threads_
>                           << " / å­˜æ´»çº¿ç¨‹: " << alive_threads_
>                           << " / å®¹å™¨çº¿ç¨‹: " << workers_.size()
>                           << " | é˜Ÿåˆ—é•¿åº¦: " << tasks_.size()
>                           << " | å·²å®Œæˆä»»åŠ¡: " << completed_tasks_ << "\n";
>             }
>         }
>     }
> 
>     void CleanUpDeadThreads() {
>         workers_.erase(std::remove_if(workers_.begin(), workers_.end(), [](const std::thread &t) { return !t.joinable(); }),
>                        workers_.end());
>     }
> };
> 
> int main() {
>     SmartThreadPool pool(2, 6, std::chrono::milliseconds(1500));
> 
>     pool.Enqueue([] {
>         std::cout << "é«˜ä¼˜å…ˆçº§ä»»åŠ¡\n";
>         std::this_thread::sleep_for(std::chrono::milliseconds(500)); }, 10);
> 
>     for (int i = 0; i < 10; ++i) {
>         pool.Enqueue([i] {
>             std::cout << "ä»»åŠ¡ " << i << "\n";
>             std::this_thread::sleep_for(std::chrono::milliseconds(300)); }, i % 5);
>     }
> 
>     std::this_thread::sleep_for(std::chrono::seconds(8));
>     std::cout << "ä¸»çº¿ç¨‹ç»“æŸ\n";
> }
> ```
>
> 
