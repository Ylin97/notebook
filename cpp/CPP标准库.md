# CPP标准库  

[toc]

## IO库 

1. `IO`库定义了三个刷新缓冲区的操纵符：

   - `endl`：往缓冲区插入一个换行符，并刷新缓冲区
   - `flush`：不插入任何额外字符，直接刷新缓冲区
   - `ends`：往缓冲区插入一个空字符，并刷新缓冲区

   以上三个操纵符只对本次操作有效，下次执行刷新操作需重新设置。如果想在每次操作后都刷新缓冲区，可以使用`unitbuf`操纵符。它告诉流在接下来的每次操作之后都进行一次`flush`操作，直到遇到`nounitbuf`操纵符将流重置。`cerr`对象默认是设置了`unitbuf`的。

   ```cpp
   cout << unitbuf;   // 所有输出操作后都会立即刷新缓冲区
   // 任何输出都立即刷新，无缓冲
   cout << nounitbuf; //回到正常的缓冲方式
   ```

    > **注意！！**如果程序异常终止，输出缓冲区是不会被刷新的。当一个程序崩溃后，它所输出的数据可能停留在输出缓冲区中等待打印。所以，当调试一个崩溃的程序时，一定要确保那些自己认为已经输出的数据确实已经刷新了，避免误认为代码没有执行的假象！！（最好的做法是，错误信息用`cerr`输出）

2. 交互式系统通常应该关联输入流与输出流。默认情况下，标准库将`cout`和`cin`关联在一起。

## 顺序容器 

1. C++标准库定义的顺序容器：

   | 容器类型            | 特点                                                 |
   | :------------------ | :--------------------------------------------------- |
   | `std::vector`       | 动态大小数组，支持快速随机访问                       |
   | `std::deque`        | 双端队列，支持快速的首尾插入和删除操作               |
   | `std::list`         | 双向链表，支持快速的插入和删除操作，但不支持随机访问 |
   | `std::forward_list` | 单向链表，只支持快速的插入和删除操作，不支持随机访问 |
   | `std::array`        | 固定大小数组，支持快速随机访问                       |
   | `std::string`       | 动态大小字符串，支持快速随机访问                     |
   | `std::wstring`      | 宽字符版本的动态大小字符串                           |
   | `std::u16string`    | UTF-16编码的动态大小字符串                           |
   | `std::u32string`    | UTF-32编码的动态大小字符串                           |

2. 容器初始化时，只有顺序容器接受大小参数。

   - `C seq(n)` ：seq 包含 n 个元素，这些元素进行了值初始化；此构造函数是 explicit 的
   - `C seq(n, t)`：seq 包含了初始化为值 t 的元素

3. 与内置数组类型不同，`array`可以进行拷贝或对象赋值操作。

   ```cpp
   int digs[3] = {1, 3, 5};
   int cpy[3] = digs;           // 错误，内置数组不支持拷贝或赋值
   array<int, 3> digits = {2, 4, 6};
   array<int, 3> copy = digits; // 正确：只要数组类型匹配即可
   ```

4. 除`array`和`string`外，其他容器使用`swap`不会导致指向容器的迭代器、引用和指针失效。同时，除`array`外，`swap`不对任何元素进行拷贝、删除或插入操作，它仅仅是交换了两个容器的内部数据结构（即名字），所以它通常比拷贝要快得多。

   ```cpp
   vector<string> svec1{"Hi", "Welcome", "CPP"};
   vector<string> svec2{"This", "is", "Dream"};
   swap(svec1, svec2); 
   // 此时，svec1: {"This", "is", "Dream"};    svec2:{"Hi", "Welcome", "CPP"};
   // 假设iter在swap之前指向svec1[2]的string，那么在swap之后它指向svec2[2]的元素。
   ```

   > 通常建议使用非成员函数版本的`swap`。

5. 由于往容器中添加/删除元素会导致迭代器失效，因此**不要保存`end()`返回的迭代器**，而应该每次判断是否遍历到末尾时都调用`end()`获取一次。

6. `reserve`只改变容器的容量，不改变元素的数目；`resize`只改变元素的数目，不改变容器的容量。`shrink_to_fit`可以要求容器退还不需要的内存空间。

7. `stack`、`queue`和`priority_queue`是**容器适配器**。默认情况下，`stack`和`queue`是基于`deque`实现的，`priority_queue`是基于`vector`实现的。我们可以在创建一个适配器时将一个命名的顺序容器作为第二个类型参数。三个容器各自的常用操作

   | 适配器名称 | 操作  |
   | ---------- | ----- |
   | `stack`    | `push`：将元素压入栈顶；`top`：返回栈顶元素，但不删除它；`pop`：移除栈顶元素 |
   | `queue` | `push`：将元素压入队尾；`front`：返回队首元素，但不删除它；`back`：返回队尾元素，但不移除它；`pop`：移除队首元素 |
   | `priority_queue` | `push`：根据优先级将元素压入优先队列；`top`：返回当前最高优先级的元素，但不删除它；`pop`：移除当前最高优先级的元素 |
   
## 泛型算法

1. `std::string`的`find`通过返回`std::string::npos`（即-1）来表示查找失败，而泛型算法`find`则通过返回第二个参数（即尾后迭代器）来表示查找失败。

2. 泛型算法是基于迭代器运行的，所以它们永远不会改变底层容器的大小。

3. 泛型算法参数中的第一对迭代器通常称为“**输入范围**”。对于只读算法，输入范围最好使用`cbegin()`和`cend()`来获取。

4. 那些只接受一个单一迭代器来表示第二个序列的算法，都假定第二个序列至少与第一个序列一样长，例如`equal`。

5. 除了重载`<`或`==`等运算符作为泛型算法对元素进行的操作外（如`sort`、`equal`等），还可以直接在泛型算法的参数中指定对元素执行的操作。这个表示“操作”的参数称为“**谓词**”，标准库算法所使用的谓词分为两类：

   - 一元谓词：它们只接受单一参数
   - 二元谓词：它们接受两个参数

   如果将不同的函数作为谓词，那它最多只能有两个参数，所以对于超过两个参数的谓词，必须使用`lambda`表达式。

6. `lambda`表达式如果返回值不能自动推断则必须使用**尾置返回**来指定返回类型。我们可以忽略参数列表和返回类型，但是必须包含捕获列表和函数体！！

   ```cpp
   // 一般形式：
   [capture list] (parameter list) -> return type { function body }
   // 省略参数列表和返回值类型
   auto f = [] { return 42; };
   ```

7. `lambda`表达式不能使用默认值参数。

8. **捕获列表**只能用于局部非`static`变量，`lambda`表达式可以直接使用局部`static`变量和在它所在函数之外声明的名字（即全局变量）。

9. 当定义一个`lambda`时，编译器生成一个与`lambda`对应的新的（未命名）类类型，而它捕获的变量会成为新类型的数据成员，并在类对象创建时被初始化。当`lambda`作为函数参数传递或者作为变量的初始值时，编译器同时定义了一个新类型和该类型的一个对象。

10. `lambda`对变量的捕获方式分为**值捕获**（默认）和**引用捕获**。除了可以显示地指定变量及其捕获方式外，`lambda`还支持隐式捕获：

    ```cpp
    auto f = [&] () { /*code*/ };     // 隐式地对外部函数的所有变量进行引用捕获
    auto f = [=] () { /*code*/ };     // 隐式地对外部函数的所有变量进行值捕获
    auto f = [&, c] () { /*code*/ };  // 对c进行值捕获，而其他外部函数中的变量进行引用捕获
    auto f = [=, &c] () { /*code*/ }; // 对c进行引用捕获，而其他外部函数中的变量进行值捕获
    ```

    需要注意的是，如上面代码所示，当混用显式捕获和隐式捕获时，显示捕获的变量必须使用与隐式捕获不同的捕获方式。

11. 默认情况下，`lambda`表达式对捕获的变量是“只读”的，即使它们是以值捕获的方式捕获的，这意味着不能在`lambda`内部修改这些变量。如果你需要在`lambda`内部修改捕获的变量，可以使用`mutable`关键字。

    ```cpp
      int main() {
          int a = 10;
          auto f = [a] () mutable { return a = 100; }; // 必须在参数列表后面使用mutable，否则会编译错误。另外，在使用mutable时，空参数列表的()也不能省略}
    ```

12. 头文件`iterator`中定义了额外几种迭代器：插入迭代器、流迭代器、反向迭代器和移动迭代器。【[详情](./C++迭代器小结.md)】

    - **插入迭代器**：它们被绑定到一个容器上，可用来向容器插入元素。
    - **流迭代器**：它们被绑定到输入或者输出流上，可用来遍历所有关联的IO流。
    - **反向迭代器**：它们向后而不是向前移动，除了`forward_list`之外的标准库容器都有反向迭代器。
    - **移动迭代器**：它们通过移动语义来移动其中的元素。

13. 根据迭代器支持的操作不同，可以分为五个类别【[详情](./C++迭代器小结.md)】：

    |   迭代器类比   |                 操作                 |
    | :------------: | :----------------------------------: |
    |   输入迭代器   |    只读，不写；单遍扫描，只能递增    |
    |   输出迭代器   |    只写，不读；单遍扫描，只能递增    |
    |   前向迭代器   |      可读写；多遍扫描，只能递增      |
    |   双向迭代器   |     可读写；多遍扫描，可递增递减     |
    | 随机访问迭代器 | 可读写；多遍扫描，支持全部迭代器运算 |

    以上分类形成了一个层次，即除输出迭代器之外，**一个高层类别的迭代器支持底层类别迭代器的所有操作**。C++标准指明了泛型和数值算法的每个迭代器参数的最小类别。


14. 大多数泛型算法具有如下四种参数形式之一：
    - `alg(beg, end, other_args);`
    - `alg(beg, end, dest, other_args)`;
    - `alg(beg, end, beg2, other_args);`
    - `alg(beg, end, beg2, end2, other_args);`

## 关联容器

**按关键字有序保存元素：**

| 容器名称   | 特点                                    |
| ---------- | --------------------------------------- |
| `map`      | 关联数组；保存键-值对（底层是“红黑树”） |
| `set`      | 关键字即值，即只保存关键字的容器        |
| `multimap` | 关键字可重复出现的`map`                 |
| `multiset` | 关键字可重复出现的`set`                 |

**关键字无序保存元素：**

| 容器名称             | 特点                              |
| -------------------- | --------------------------------- |
| `unordered_map`      | 用哈希函数组织的`map`             |
| `unordered_set`      | 用哈希函数组织的`set`             |
| `unordered_multimap` | 哈希组织的`map`；关键字可重复出现 |
| `unordered_multiset` | 哈希组织的`set`；关键字可重复出现 |

