# CPP标准库  

[toc]

## IO库 

1. `IO`库定义了三个刷新缓冲区的操纵符：

   - `endl`：往缓冲区插入一个换行符，并刷新缓冲区
   - `flush`：不插入任何额外字符，直接刷新缓冲区
   - `ends`：往缓冲区插入一个空字符，并刷新缓冲区

   以上三个操纵符只对本次操作有效，下次执行刷新操作需重新设置。如果想在每次操作后都刷新缓冲区，可以使用`unitbuf`操纵符。它告诉流在接下来的每次操作之后都进行一次`flush`操作，直到遇到`nounitbuf`操纵符将流重置。`cerr`对象默认是设置了`unitbuf`的。

   ```cpp
   cout << unitbuf;   // 所有输出操作后都会立即刷新缓冲区
   // 任何输出都立即刷新，无缓冲
   cout << nounitbuf; //回到正常的缓冲方式
   ```

    > **注意！！**如果程序异常终止，输出缓冲区是不会被刷新的。当一个程序崩溃后，它所输出的数据可能停留在输出缓冲区中等待打印。所以，当调试一个崩溃的程序时，一定要确保那些自己认为已经输出的数据确实已经刷新了，避免误认为代码没有执行的假象！！（最好的做法是，错误信息用`cerr`输出）

2. 交互式系统通常应该关联输入流与输出流。默认情况下，标准库将`cout`和`cin`关联在一起。

## 顺序容器 

1. C++标准库定义的顺序容器：

   | 容器类型            | 特点                                                 |
   | :------------------ | :--------------------------------------------------- |
   | `std::vector`       | 动态大小数组，支持快速随机访问                       |
   | `std::deque`        | 双端队列，支持快速的首尾插入和删除操作               |
   | `std::list`         | 双向链表，支持快速的插入和删除操作，但不支持随机访问 |
   | `std::forward_list` | 单向链表，只支持快速的插入和删除操作，不支持随机访问 |
   | `std::array`        | 固定大小数组，支持快速随机访问                       |
   | `std::string`       | 动态大小字符串，支持快速随机访问                     |
   | `std::wstring`      | 宽字符版本的动态大小字符串                           |
   | `std::u16string`    | UTF-16编码的动态大小字符串                           |
   | `std::u32string`    | UTF-32编码的动态大小字符串                           |

2. 容器初始化时，只有顺序容器接受大小参数。

   - `C seq(n)` ：seq 包含 n 个元素，这些元素进行了值初始化；此构造函数是 explicit 的
   - `C seq(n, t)`：seq 包含了初始化为值 t 的元素

3. 与内置数组类型不同，`array`可以进行拷贝或对象赋值操作。

   ```cpp
   int digs[3] = {1, 3, 5};
   int cpy[3] = digs;           // 错误，内置数组不支持拷贝或赋值
   array<int, 3> digits = {2, 4, 6};
   array<int, 3> copy = digits; // 正确：只要数组类型匹配即可
   ```

4. 除`array`和`string`外，其他容器使用`swap`不会导致指向容器的迭代器、引用和指针失效。同时，除`array`外，`swap`不对任何元素进行拷贝、删除或插入操作，它仅仅是交换了两个容器的内部数据结构（即名字），所以它通常比拷贝要快得多。

   ```cpp
   vector<string> svec1{"Hi", "Welcome", "CPP"};
   vector<string> svec2{"This", "is", "Dream"};
   swap(svec1, svec2); 
   // 此时，svec1: {"This", "is", "Dream"};    svec2:{"Hi", "Welcome", "CPP"};
   // 假设iter在swap之前指向svec1[2]的string，那么在swap之后它指向svec2[2]的元素。
   ```

   > 通常建议使用非成员函数版本的`swap`。

5. 由于往容器中添加/删除元素会导致迭代器失效，因此**不要保存`end()`返回的迭代器**，而应该每次判断是否遍历到末尾时都调用`end()`获取一次。

6. `reserve`只改变容器的容量，不改变元素的数目；`resize`只改变元素的数目，不改变容器的容量。`shrink_to_fit`可以要求容器退还不需要的内存空间。

7. `stack`、`queue`和`priority_queue`是**容器适配器**。默认情况下，`stack`和`queue`是基于`deque`实现的，`priority_queue`是基于`vector`实现的。我们可以在创建一个适配器时将一个命名的顺序容器作为第二个类型参数。三个容器各自的常用操作

   | 适配器名称 | 操作  |
   | ---------- | ----- |
   | `stack`    | `push`：将元素压入栈顶；`top`：返回栈顶元素，但不删除它；`pop`：移除栈顶元素 |
   | `queue` | `push`：将元素压入队尾；`front`：返回队首元素，但不删除它；`back`：返回队尾元素，但不移除它；`pop`：移除队首元素 |
   | `priority_queue` | `push`：根据优先级将元素压入优先队列；`top`：返回当前最高优先级的元素，但不删除它；`pop`：移除当前最高优先级的元素 |
   
## 泛型算法

1. `std::string`的`find`通过返回`std::string::npos`（即-1）来表示查找失败，而泛型算法`find`则通过返回第二个参数（即尾后迭代器）来表示查找失败。

2. 泛型算法是基于迭代器运行的，所以它们永远不会改变底层容器的大小。

3. 泛型算法参数中的第一对迭代器通常称为“**输入范围**”。对于只读算法，输入范围最好使用`cbegin()`和`cend()`来获取。

4. 那些只接受一个单一迭代器来表示第二个序列的算法，都假定第二个序列至少与第一个序列一样长，例如`equal`。

5. 除了重载`<`或`==`等运算符作为泛型算法对元素进行的操作外（如`sort`、`equal`等），还可以直接在泛型算法的参数中指定对元素执行的操作。这个表示“操作”的参数称为“**谓词**”，标准库算法所使用的谓词分为两类：

   - 一元谓词：它们只接受单一参数
   - 二元谓词：它们接受两个参数

   如果将不同的函数作为谓词，那它最多只能有两个参数，所以对于超过两个参数的谓词，必须使用`lambda`表达式。

6. `lambda`表达式如果返回值不能自动推断则必须使用**尾置返回**来指定返回类型。我们可以忽略参数列表和返回类型，但是必须包含捕获列表和函数体！！

   ```cpp
   // 一般形式：
   [capture list] (parameter list) -> return type { function body }
   // 省略参数列表和返回值类型
   auto f = [] { return 42; };
   ```

7. `lambda`表达式不能使用默认值参数。

8. **捕获列表**只能用于局部非`static`变量，`lambda`表达式可以直接使用局部`static`变量和在它所在函数之外声明的名字（即全局变量）。

9. 当定义一个`lambda`时，编译器生成一个与`lambda`对应的新的（未命名）类类型，而它捕获的变量会成为新类型的数据成员，并在类对象创建时被初始化。当`lambda`作为函数参数传递或者作为变量的初始值时，编译器同时定义了一个新类型和该类型的一个对象。

10. `lambda`对变量的捕获方式分为**值捕获**（默认）和**引用捕获**。除了可以显示地指定变量及其捕获方式外，`lambda`还支持隐式捕获：

    ```cpp
    auto f = [&] () { /*code*/ };     // 隐式地对外部函数的所有变量进行引用捕获
    auto f = [=] () { /*code*/ };     // 隐式地对外部函数的所有变量进行值捕获
    auto f = [&, c] () { /*code*/ };  // 对c进行值捕获，而其他外部函数中的变量进行引用捕获
    auto f = [=, &c] () { /*code*/ }; // 对c进行引用捕获，而其他外部函数中的变量进行值捕获
    ```

    需要注意的是，如上面代码所示，当混用显式捕获和隐式捕获时，显示捕获的变量必须使用与隐式捕获不同的捕获方式。

11. 默认情况下，`lambda`表达式对捕获的变量是“只读”的，即使它们是以值捕获的方式捕获的，这意味着不能在`lambda`内部修改这些变量。如果你需要在`lambda`内部修改捕获的变量，可以使用`mutable`关键字。

    ```cpp
      int main() {
          int a = 10;
          auto f = [a] () mutable { return a = 100; }; // 必须在参数列表后面使用mutable，否则会编译错误。另外，在使用mutable时，空参数列表的()也不能省略}
    ```

12. `std::bind`用于创建一个函数对象，它可以绑定函数的部分参数，从而创建一个新的可调用对象。它主要有下面几种用法：

    - 绑定部分参数
    - 调整参数顺序
    - 绑定成员函数和成员变量（需要用的**成员函数指针**和**成员变量指针**）

    ```cpp
    // bind实际上是一个函数封装器，auto f1 = bind(print, x, _1); 可以用下面的伪代码进行理解:
    // void f1(_1) {
    //    auto x2 = x; // x的值被拷贝到x2
    //    print(x2, _1);
    // }
    //

    /// 绑定部分参数，适用于原函数部分参数已确定，不需要外部输入的场合 ///
    void print(int a, int b) { cout << a << ", " << b << endl; }

    void func1(int x = 5) {
      auto f1 = bind(print, _1, 3); // 将print的第二个参数绑定为定值3，而它的第一个参数通过调用f1时传递
      auto f2 = bind(print, x, _1); // 将print的第一个参数绑定为变量x，而它的第二个参数通过调用f2时传递

      f1(1); // 输出：1, 3
      f2(2); // 输出：5, 2 (假设外部直接调用func1())
    }

    /// 调整参数顺序 ///
    void func2() {
      auto f = bind(print, _2, _1); // f与print的参数顺序是相反的
    }

    /// 绑定成员函数与成员变量，这里需要用到 成员函数指针 和 成员变量指针 ///
    class MyClass {
    public:
      int value = 42;
      void print(int x) const {
          cout << "Value: " << x << endl;
      }
    }

    void func3() {
      MyClass obj;
      // 绑定成员函数，&MyClass::print 表示获取成员函数的地址，它返回一个成员函数指针
      auto bound_print1 = bind(&MyClass::print, &obj, _1);
      auto bound_print2 = bind(&MyClass::print, _1, _2);// _1必须是MyClass的对象
      // 绑定成员变量，&MyClass::value 表示获取成员变量的地址，它返回一个成员变量指针
      auto bound_value1 = bind(&MyClass::value, &obj);
      auto bound_value2 = bind(&MyClass::value, _1);// _1必须是MyClass的对象

      bound_print1(3); // 输出：Value: 3
      bound_print2(4); // 输出：Value: 4
      // 注意bind绑定成员变量时生成的可调用对象，在调用时返回的是成员变量的值！
      cout << bound_value1() << endl; // 输出：42
      cout << bound_value2() << endl; // 输出：42
    }
    ```

    默认情况下，`bind`的那些不是占位符的参数被拷贝到`bind`返回的可调用对象中，如果想要采用引用方式绑定，则必须使用`ref`函数：

    ```cpp
    for_each(words.begin(), words.end(), bind(print, ref(os), _1, ' '));
    ```

    `std::bind`在需要部分应用函数参数或封装可调用对象时非常有用，但在现代C++开发中，其使用频率逐渐被`lambda`表达式替代。

13. 头文件`iterator`中定义了额外几种迭代器：插入迭代器、流迭代器、反向迭代器和移动迭代器。【[详情](./C++迭代器小结.md)】

    - **插入迭代器**：它们被绑定到一个容器上，可用来向容器插入元素。
    - **流迭代器**：它们被绑定到输入或者输出流上，可用来遍历所有关联的IO流。
    - **反向迭代器**：它们向后而不是向前移动，除了`forward_list`之外的标准库容器都有反向迭代器。
    - **移动迭代器**：它们通过移动语义来移动其中的元素。

14. 根据迭代器支持的操作不同，可以分为五个类别【[详情](./C++迭代器小结.md)】：

    |   迭代器类比   |                 操作                 |
    | :------------: | :----------------------------------: |
    |   输入迭代器   |    只读，不写；单遍扫描，只能递增    |
    |   输出迭代器   |    只写，不读；单遍扫描，只能递增    |
    |   前向迭代器   |      可读写；多遍扫描，只能递增      |
    |   双向迭代器   |     可读写；多遍扫描，可递增递减     |
    | 随机访问迭代器 | 可读写；多遍扫描，支持全部迭代器运算 |

    以上分类形成了一个层次，即除输出迭代器之外，**一个高层类别的迭代器支持底层类别迭代器的所有操作**。C++标准指明了泛型和数值算法的每个迭代器参数的最小类别。


15. 大多数泛型算法具有如下四种参数形式之一：
    - `alg(beg, end, other_args);`
    - `alg(beg, end, dest, other_args)`;
    - `alg(beg, end, beg2, other_args);`
    - `alg(beg, end, beg2, end2, other_args);`

## 关联容器

1. 概述

   **按关键字有序保存元素<sup>*</sup>：**

   | 容器名称   | 特点                             |
   | ---------- | -------------------------------- |
   | `map`      | 关联数组；保存键-值对            |
   | `set`      | 关键字即值，即只保存关键字的容器 |
   | `multimap` | 关键字可重复出现的`map`          |
   | `multiset` | 关键字可重复出现的`set`          |  

   > P.S. 由于大部分编译器的有序容器底层是红黑树，所以加入/删除元素时会进行排序，所以必须定义关键字的比较方式，默认是通过关键字类型的`<`运算符进行比较。换句话说，只要一个类型定义了“行为正常”的`<`运算符，它就可以作为关键字。

   **关键字无序保存元素：**

   | 容器名称             | 特点                              |
   | -------------------- | --------------------------------- |
   | `unordered_map`      | 用哈希函数组织的`map`             |
   | `unordered_set`      | 用哈希函数组织的`set`             |
   | `unordered_multimap` | 哈希组织的`map`；关键字可重复出现 |
    | `unordered_multiset` | 哈希组织的`set`；关键字可重复出现 |

   > 无序容器使用一个哈希函数和关键字类型的`==`运算符来组织元素。它在存储上组织为一组桶。默认情况下，无序容器使用关键字类型的`==`运算符来比较元素，同时还是用一个`hash<key_type>`类型的对象来生成每个元素的哈希值。标准库为内置类型以及一些标准库类型（`string`和`智能指针`）定义了hash模板，所以可以直接用这些类型作为关键字。而自定义的类型，则必须提供对应的hash模板才可以。

   **关联容器额外的类型名：**

   | 类型          | 解释                                                         |
   | ------------- | ------------------------------------------------------------ |
   | `key_type`    | 此容器类型的关键字类型                                       |
   | `mapped_type` | 每个关键字关联的类型，只适用于`map`                          |
   | `value_type`  | 对于`set`，该值与`key_type`相同；对于`map`，该值为`pair<const key_type, mapped_type>` |

   > P.S. 由于`key_type`是const的，所以不能修改`map`的关键字，但是可以修改`mapped_type`；而`set`的关键字就是其值，所以不能修改它的元素值。虽然`set`类型同时定义了`iterator`和`const_iterator`类型，但是两种类型都只允许只读访问其中的元素。

2. 关联容器的访问方式：

    **公共访问方式：**

    - 使用迭代器访问
    - 使用范围for遍历
    - 使用`find`查找元素

    **`map`和`unordered_map`特有的访问方式：**

    - `operator[]`：通过键直接访问，如果键不存在会插入新元素（并进行值初始化）
    - `at`：类似于 `operator[]`，但会抛出异常，如果键不存在

    > P.S. 不能对一个`multimap`或`unordered_multimap`进行下标操作，因为它们可能有多个值与一个关键字关联。

3. `map`容器族的迭代器指向的是一个`pair`，所以需要分别访问`first`和`second`成员；而`set`容器族的迭代器指向的是一个单独的元素，而不是`pair`，所以可以直接访问迭代器指向的元素。

4. 构建`vector<pair<T1, T2>>`最好的方式是使用`vec.emplace_back(T1, T2)`。

5. 一般不对关联容器应用泛型算法。这一是由于关联容器的关键字是const的，所以只能对关联容器使用“只读”算法；二是因为即使是只读取元素的算法，很多也要求搜索排序，而关联容器使用泛型`find`查找效率非常低（**关联容器应该使用自身定义的`find`来查找元素**）。在实际编程中，如果真要对一个关联容器使用算法，要么将它当作一个源序列，要么当作一个目的位置。

6. 对于不包含重复关键字的关联容器，执行添加单一元素的`insert`或`emplace`时，应该检查其返回值。`insert`返回一个`pair`，其中`first`是指向新添加的元素，而`second`是一个表示是否添加成功的布尔值（当元素已经存在时，它的值为`false`）。因为`multi`版本的关联容器执行添加单元素的`insert`或`emplace`时总会添加元素，所以它们只返回一个指向新元素的迭代器。

## 动态内存管理

1. 最安全的分配和使用动态内存的方法是使用`make_shared`标准库函数。

   - `make_shared<T>(args)`：返回一个`shared_ptr`，指向一个动态分配的类型`T`的对象，并使用`args`初始化此对象。

2. 如果将`shared_ptr`存放在一个容器中，那一定要记得及时调用`erase`删除掉不再需要的元素，否则`shared_ptr`的引用计数不会递减！

3. 默认情况下，`new`动态分配的对象是默认初始化的，所以内置类型或组合类型的对象不会初始化（垃圾值），而类类型则会调用默认构造函数进行初始化。通常应该对动态分配的对象使用`()`或`{}`进行显式初始化，并且当`()`中仅有单一初始化器时，可以使用`auto`进行类型推导：【[默认初始化与值初始化的区别](./C++默认初始化和值初始化小结.md)】

   ```cpp
   int pi1 = new int;            // 默认初始化，*pi1的值未定义
   int pi2 = new int();          // 值初始化为0，*pi2为0
   string* ps1 = new string;     // 默认初始化为空string
   string* ps2 = new string();   // 值初始化为空string
   
   auto p1 = new auto(obj);      // p指向一个与obj类型相同的对象
   auto p2 = new auto{a, b, c};  // 错误：括号中只能有单个初始化器
   ```

   
