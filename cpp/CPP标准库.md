# CPP标准库  

1. `IO`库定义了三个刷新缓冲区的操纵符：

   - `endl`：往缓冲区插入一个换行符，并刷新缓冲区
   - `flush`：不插入任何额外字符，直接刷新缓冲区
   - `ends`：往缓冲区插入一个空字符，并刷新缓冲区

   以上三个操纵符只对本次操作有效，下次执行刷新操作需重新设置。如果想在每次操作后都刷新缓冲区，可以使用`unitbuf`操纵符。它告诉流在接下来的每次操作之后都进行一次`flush`操作，直到遇到`nounitbuf`操纵符将流重置。`cerr`对象默认是设置了`unitbuf`的。

   ```cpp
   cout << unitbuf;   // 所有输出操作后都会立即刷新缓冲区
   // 任何输出都立即刷新，无缓冲
   cout << nounitbuf; //回到正常的缓冲方式
   ```

    > **注意！！**如果程序异常终止，输出缓冲区是不会被刷新的。当一个程序崩溃后，它所输出的数据可能停留在输出缓冲区中等待打印。所以，当调试一个崩溃的程序时，一定要确保那些自己认为已经输出的数据确实已经刷新了，避免误认为代码没有执行的假象！！（最好的做法是，错误信息用`cerr`输出）

2. 交互式系统通常应该关联输入流与输出流。默认情况下，标准库将`cout`和`cin`关联在一起。

3. C++标准库定义的顺序容器：

   | 容器类型            | 特点                                                 |
   | :------------------ | :--------------------------------------------------- |
   | `std::vector`       | 动态大小数组，支持快速随机访问                       |
   | `std::deque`        | 双端队列，支持快速的首尾插入和删除操作               |
   | `std::list`         | 双向链表，支持快速的插入和删除操作，但不支持随机访问 |
   | `std::forward_list` | 单向链表，只支持快速的插入和删除操作，不支持随机访问 |
   | `std::array`        | 固定大小数组，支持快速随机访问                       |
   | `std::string`       | 动态大小字符串，支持快速随机访问                     |
   | `std::wstring`      | 宽字符版本的动态大小字符串                           |
   | `std::u16string`    | UTF-16编码的动态大小字符串                           |
   | `std::u32string`    | UTF-32编码的动态大小字符串                           |

4. 容器初始化时，只有顺序容器接受大小参数。

   - `C seq(n)` ：seq 包含 n 个元素，这些元素进行了值初始化；此构造函数是 explicit 的
   - `C seq(n, t)`：seq 包含了初始化为值 t 的元素

5. 与内置数组类型不同，`array`可以进行拷贝或对象赋值操作。

   ```cpp
   int digs[3] = {1, 3, 5};
   int cpy[3] = digs;           // 错误，内置数组不支持拷贝或赋值
   array<int, 3> digits = {2, 4, 6};
   array<int, 3> copy = digits; // 正确：只要数组类型匹配即可
   ```

6. 除`array`和`string`外，其他容器使用`swap`不会导致指向容器的迭代器、引用和指针失效。同时，除`array`外，`swap`不对任何元素进行拷贝、删除或插入操作，它仅仅是交换了两个容器的内部数据结构（即名字），所以它通常比拷贝要快得多。

   ```cpp
   vector<string> svec1{"Hi", "Welcome", "CPP"};
   vector<string> svec2{"This", "is", "Dream"};
   swap(svec1, svec2); 
   // 此时，svec1: {"This", "is", "Dream"};    svec2:{"Hi", "Welcome", "CPP"};
   // 假设iter在swap之前指向svec1[2]的string，那么在swap之后它指向svec2[2]的元素。
   ```

   > 通常建议使用非成员函数版本的`swap`。

7. 由于往容器中添加/删除元素会导致迭代器失效，因此**不要保存`end()`返回的迭代器**，而应该每次判断是否遍历到末尾时都调用`end()`获取一次。

8. `reserve`只改变容器的容量，不改变元素的数目；`resize`只改变元素的数目，不改变容器的容量。`shrink_to_fit`可以要求容器退还不需要的内存空间。

9. `stack`、`queue`和`priority_queue`是**容器适配器**。默认情况下，`stack`和`queue`是基于`deque`实现的，`priority_queue`是基于`vector`实现的。我们可以在创建一个适配器时将一个命名的顺序容器作为第二个类型参数。

