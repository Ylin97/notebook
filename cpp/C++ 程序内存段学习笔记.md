# C++ 程序内存段学习笔记

## 1. 程序中的主要段（Segments / Sections）

| 段名                             | 内容                                    | 特性               | 举例                                   |
| -------------------------------- | --------------------------------------- | ------------------ | -------------------------------------- |
| `.text`                          | 代码段                                  | 只读 + 可执行      | 函数体、类方法、`main()`               |
| `.rodata`                        | 只读数据                                | 只读               | 字符串常量、`const` 全局变量、虚函数表 |
| `.data`                          | 已初始化的全局/静态变量                 | 可读写             | `int g=42; static int s=7;`            |
| `.bss`                           | 未初始化（或初始化为 0）的全局/静态变量 | 可读写，初始为 0   | `int g; static int s;`                 |
| `.init_array`                    | 全局构造函数表                          | 可读写             | 全局对象构造函数指针                   |
| `.fini_array`                    | 全局析构函数表                          | 可读写             | 全局对象析构函数指针                   |
| `.eh_frame`, `.gcc_except_table` | 异常处理表                              | 只读               | C++ `try/catch` 支持                   |
| `.symtab`, `.strtab`, `.debug_*` | 符号/调试信息                           | 只在调试构建时存在 | 用于 gdb/lldb 调试                     |

------

## 2. 各类变量对应的段

| 变量类型                 | 示例                    | 所在段            |
| ------------------------ | ----------------------- | ----------------- |
| 已初始化全局变量         | `int g = 42;`           | `.data`           |
| 未初始化全局变量         | `int g;`                | `.bss`            |
| 已初始化 static 全局变量 | `static int s = 7;`     | `.data`           |
| 未初始化 static 全局变量 | `static int s;`         | `.bss`            |
| 函数内 static            | `static int counter=0;` | `.data` 或 `.bss` |
| const 全局变量           | `const int c = 99;`     | `.rodata`         |
| 字符串常量               | `"Hello"`               | `.rodata`         |
| 普通函数体               | `void foo(){}`          | `.text`           |

------

## 3. 文件中的排列（编译产物）

- 段在 **可执行文件**里是**分散的块**，由段表记录位置和大小。
- 不一定连续，中间可能有填充（对齐到 4KB 页大小）。
- `.bss` 在文件中是 **NOBITS**（不占磁盘空间，只记录大小），运行时才分配。

------

## 4. 运行时内存布局（Linux ELF 常见情况）

进程虚拟地址空间中的常见顺序（低地址 → 高地址）：

```
│  .text       # 代码段 (只读+可执行)
│  .rodata     # 只读数据 (常量、字符串字面量)
│  .data       # 已初始化全局/静态变量 (可读写)
│  .bss        # 未初始化全局/静态变量 (可读写, 初始为0)
│
│  堆 (heap)   # malloc/new，向上增长
│
│  动态库区    # mmap/共享库加载区
│
│  栈 (stack)  # 函数调用栈帧，局部变量，向下增长
```

👉 注意：

- 段之间**大致相邻**，但可能有对齐空洞。
- 操作系统会对不同段设置 **保护属性**（例如 `.text` 可执行但不可写，`.rodata` 只读）。

------

## 5. Windows PE 程序中的常见段

| 段名     | 内容                     |
| -------- | ------------------------ |
| `.text`  | 代码段                   |
| `.rdata` | 只读数据（常量、字符串） |
| `.data`  | 已初始化全局/静态变量    |
| `.bss`   | 未初始化全局/静态变量    |
| `.idata` | 导入表（动态库函数）     |
| `.edata` | 导出表                   |
| `.pdata` | 异常处理信息             |
| `.rsrc`  | 程序资源（图标、菜单等） |
| `.reloc` | 重定位信息（DLL/ASLR）   |

------

## 6. 关键点总结

- **全局变量 & 静态变量** → 都属于 **静态存储期对象**，存活整个程序运行期。
- **已初始化 vs 未初始化** → 分别放在 `.data` 和 `.bss`。
- **常量数据**（`const`，字符串字面量）→ `.rodata`。
- **函数体** → `.text` 段（代码段）。
- **程序运行时**，静态区（`.text/.rodata/.data/.bss`）大体相邻，但不保证完全连续，中间可能有对齐和保护分隔。
- **堆和栈** 在静态区之外，分别用于动态分配和局部变量。

------

> 栈相关知识
> #### 1. 栈的增长方向
>
> - **栈总是向低地址增长**（在绝大多数操作系统和 CPU 架构上都是这样）。
> - 也就是说，每次函数调用时，会在栈上分配新的栈帧，栈顶（stack pointer, `rsp`/`esp`）会减小。
> - 栈的底（stack base）就是 **系统分配给线程的栈起始地址**，通常在 **高地址区**。
>
> ------
>
> #### 2. 栈的起始位置
>
> - 不一定是整个虚拟内存的**最高地址**，但通常是在用户空间可用虚拟地址的高端。
> - 例如在 Linux x86_64：
>
> ```
> 0x00007fffffff0000  ← 用户空间高地址
> │
> │ 栈顶 (stack pointer, rsp)
> │ 栈向下增长
> │ ...
> 0x0000000000400000  ← 代码段低地址
> ```
>
> - 栈起始地址由 **操作系统加载器** 在进程创建时分配。
> - 每个线程都有自己的栈空间，默认大小有限（Linux 默认 8 MB，Windows 默认 1 MB）。
>
> ------
>
> #### 3. 栈的实际情况
>
> 1. **线程栈**：每个线程都有独立的栈，高地址为分配的栈顶，向低地址增长。
> 2. **栈不占满整个虚拟地址空间**：有一个“保护页”防止栈溢出直接覆盖其他段。
> 3. **多线程**：每个线程的栈都在不同虚拟地址区域，高地址不一定相同。
>
> ------
>
> #### 4. 总结
>
> - 栈的“开始位置”通常是在用户虚拟地址空间的高端，但不是全局最高地址（因为高端还有内核空间等保留区域）。
> - 栈向低地址增长，每次函数调用会把栈顶指针向下移动。
> - 堆则通常从低地址向高地址增长，栈和堆中间留有缓冲区。
>
> ------
>
> 💡 小结一句话：
>
> **栈总是高位开始、向低地址增长，但“最高地址”是相对用户空间而言，不是整个内存绝对最高地址。**
