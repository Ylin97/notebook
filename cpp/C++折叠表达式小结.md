# C++折叠表达式小结  

C++17中对可变参数模板的参数包进行了一些改进，即使用折叠表达式（Fold Expression）来简化递归式的“函数调用”。  

折叠表达式只能用于所支持的32个操作符：`+`, `-`, `*`, `/`, `%`, `^`, `&`, `|`, `=`, `<`, `>`, `<<`, `>>`, `+=`, `-=`, `*=`, `/=`, `%=`, `^=`, `&=`, `|=`, `<<=`, `>>=`, `==`, `!=`, `<=`, `>=`, `&&`, `||`, `,`, `.*`, `->*`。

**折叠表达式语法如下：**

1. 一元左折叠：`(... op pack)`

2. 一元右折叠：`(pack op ...)`

3. 二元左折叠：`(init op ... op pack)`

4. 二元右折叠：`(pack op ... op init)`

其中：

- `op`是上面的32个运算符之一
- `pack`是模板参数包
- `init`是初始值

只有三个运算符允许参数包为空：`&&`，`||`和`,`，其中`&&`为`true`，`||`为`false`，`,`为`void()`。实际上，折叠表达式只是使用标记`...`和参数包`pack`将参数展开的语法糖，任何折叠表达式都包含折叠标记、标识符和操作符三部分。

#### 参数展开 

折叠表达式的实例化将按如下方式展开表达式`E`（展开式中的括号只表示参数的展开顺序，不表示求值顺序，最后的展开结果中并不会包含这些括号！！！）：

1. 一元左折叠：`(... op pack)`：展开为 $(((E_1\:op\:E_2)\:op\:...)\:op\:E_N)$

2. 一元右折叠：`(pack op ...)`：展开为 $(E_1\:op\:(...\:op\:(E_{N-1}\:op\:E_N)))$

3. 二元左折叠：`(init op ... op pack)`：展开为 $((((I\:op\:E_1)\:op\:E_2)\:op\:...)\:op\:E_N)$

4. 二元右折叠：`(pack op ... op init)`：展开为 $(E_1\:op\:(...\:op\:(E_{N−1}\:op\:(E_N\:op\:I))))$

#### 示例

```cpp
template <typename ... Args>
auto sumL(Args... args)
{
    return (args + ...); // 右折叠
}

template <typename... Args>
auto sumR(Args... args)
{
    return (... + args); // 左折叠
}
```

当调用`sum(1，2，3，4，5)`时，右折叠会沿右侧不断将参数包展开，变为`1+(2+(3+(4+5)))`(括号只是为了说明展开方向，真实结果不会添加括号)，这其中经历了3次展开，第一次展开为`1+(2+args)`，然后继续进行第二次展开为`1+(2+(3+args))`。左折叠的展开方向与之相反。

更复杂的例子：

```cpp
template <typename... Args>
void variadicPrint(Args... args)
{
    ((std::cout << args), ...) << std::endl;
}

template <typename... Args>
void variadicPrint(Args... args)
{
    (..., (std::cout << args << std::endl)); // 左右折叠都可
}
```

其中`(std::cout < args)`(或者`(std::cout< args < std::endl))`是包含参数包的表达式，编译阶段使用逗号运算符连接展开的表达式，复制`(std::cout << args)`，并将参数包`args`替换为实际参数。
对于大部分不需要考虑结合性的情况，左折叠和右折叠没有区别；其他一些情况则需要考虑结合性，例如`std::string`的字符串字面值赋值，必须使用右折叠，因为字符串字面值是右值，不能做加运算，此外除法和减法也类似。

一些好用的例子：

```cpp
/* 能够打印任意多个参数的print */
void print(Args... args) {
    ((std::cout << args << ' '), ...);  // 使用逗号运算符，左折叠也可以: (..., (std::cout << args << ' '));
    std::cout << std::endl;              // 最后换行
}
```

